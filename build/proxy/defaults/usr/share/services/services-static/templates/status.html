<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width" />
  <title>Status</title>
  <style>
    @font-face {
      font-family: Pompiere;
      src: url('/services-static/fonts/Pompiere-Regular.ttf') format('truetype');
    }

    * {
      box-sizing: border-box;
    }

    body {
      width: 100%;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      font-family: Pompiere, sans-serif;
      color: #222;
      background: #f5f5f5;
    }

    .info-panel {
      display: grid;
      grid-template-columns: repeat(3, auto);
      align-items: center;
      gap: 20px;
      background: white;
      border-radius: 8px;
      padding: 15px 20px;
      margin-bottom: 10px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .info-text {
      margin: 0;
      white-space: nowrap;
      font-size: 1.5em;
    }

    #stack {
      text-align: center;
    }

    #tag {
      text-align: right;
    }

    .info-panel h2 {
      display: none;
    }

    .status-text {
      font-size: 2.5px;
      font-style: italic;
      fill: #000;
    }

    .svg-section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .svg-section svg {
      max-width: 100%;
      height: auto;
      display: block;
    }

    .node {
      fill: lightgray;
      transition: fill 0.3s ease;
    }

    .link {
      fill: green;
      fill-opacity: 0.07;
      cursor: pointer;
      transition: fill-opacity 0.2s ease;
    }

    .link:hover {
      fill-opacity: 0.15;
    }

    .icon {
      width: 10px;
      height: 10px;
    }

    .circle-text {
      text-anchor: middle;
      font-size: 3px;
      fill: #333;
    }

    text {
      font-size: 3px;
      font-style: italic;
      fill: #868e96;
    }

    .logs-section {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .logs-header {
      padding: 15px 20px;
      background: #f8f9fa;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #ddd;
    }

    .logs-header:hover {
      background: #e9ecef;
    }

    .logs-header h2 {
      margin: 0;
      font-size: 1.5em;
      font-weight: 100;
      color: #333;
    }

    .toggle-icon {
      font-size: 1.5em;
      transition: transform 0.3s ease;
    }

    .toggle-icon.expanded {
      transform: rotate(180deg);
    }

    .logs-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .logs-content.expanded {
      max-height: 600px;
      overflow-y: auto;
    }

    .logs-table-container {
      padding: 20px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #ddd;
    }

    th {
      background: #f8f9fa;
      font-weight: bold;
      text-transform: uppercase;
      font-size: 0.9em;
      letter-spacing: 0.5px;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    th, td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: left;
    }

    tbody tr {
      transition: background-color 0.2s ease;
    }

    tbody tr:hover {
      background-color: #f8f9fa;
    }

    tbody tr:nth-child(even) {
      background-color: #fafafa;
    }

    .loading, .error, .empty {
      padding: 40px;
      text-align: center;
      font-size: 1.2em;
      color: #666;
    }

    .error {
      color: #dc3545;
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      th, td {
        padding: 6px;
        font-size: 0.9em;
      }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .loading {
      animation: pulse 1.5s ease-in-out infinite;
    }
  </style>
</head>
<body>
  <!-- Info Panel -->
  <div class="info-panel">
    <h2>Information</h2>
    <p class="info-text" id="organization"></p>
    <p class="info-text" id="stack"></p>
    <p class="info-text" id="tag"></p>
  </div>

  <!-- SVG Section -->
  <div class="svg-section">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="5 60 180 60" id="main-svg">
      <defs>
        <filter id="glow">
          <feGaussianBlur stdDeviation="0.3" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>

      <!-- Status message -->
      <g transform="translate(160, 100)">
        <a href="/services/logs" target="_blank">
          <image id="mascot" href="/services-static/img/mascot-welcome.svg" class="link" x="6" y="8" height="10" width="10" />
        </a>
        <text class="status-text" id="message_serv"></text>
        <text class="status-text" id="message" x="0" y="3">one moment, please</text>
      </g>

      <!-- Services nodes -->
      <g id="portainer-node" transform="translate(40, 74)">
        <image class="icon" href="/services-static/img/portainer.svg" x="1" y="-12" />
        <circle id="portainer" class="node" r="1.5" filter="url(#glow)" />
        <a id="portainer_link_parent" target="_blank">
          <circle id="portainer_link" class="link" cx="7" cy="-7" r="7"><title>Portainer Console</title></circle>
        </a>
        <text x="3" y="2">portainer</text>
      </g>

      <g id="proxy-node" transform="translate(40, 94)">
        <image class="icon" href="/services-static/img/proxy.svg" x="1" y="-12" />
        <circle id="proxy" class="node" r="1.5" filter="url(#glow)" />
        <a id="proxy_link_parent" target="_blank">
          <circle id="proxy_link" class="link" cx="7" cy="-7" r="7"><title>Proxy Statistics</title></circle>
        </a>
        <text x="4" y="2">proxy</text>
      </g>

      <g id="ca-node" transform="translate(40, 114)">
        <image class="icon" href="/services-static/img/ca.svg" x="2" y="-12" />
        <circle id="ca" class="node" r="1.5" filter="url(#glow)" />
        <a id="ca_link_parent" target="_blank">
          <circle id="ca_link" class="link" cx="7" cy="-7" r="7"><title>Certificate Authority API</title></circle>
        </a>
        <text x="6" y="2">ca</text>
      </g>

      <g id="console-node" transform="translate(70, 74)">
        <image class="icon" href="/services-static/img/console.svg" x="2" y="-12" />
        <circle id="console" class="node" r="1.5" filter="url(#glow)" />
        <text id="nodes_console" class="circle-text" x="0" y="1"></text>
        <a id="console_link_parent" target="_blank">
          <circle id="console_link" class="link" cx="7" cy="-7" r="7"><title>Migasfree Console</title></circle>
        </a>
        <text x="4" y="2">console</text>
      </g>

      <g id="public-node" transform="translate(70, 94)">
        <image class="icon" href="/services-static/img/public.svg" x="2" y="-12" />
        <circle id="public" class="node" r="1.5" filter="url(#glow)" />
        <text id="nodes_public" class="circle-text" x="0" y="1"></text>
        <circle id="public_link" class="link" cx="7" cy="-7" r="7"><title>Public Files</title></circle>
        <text x="4" y="2">public</text>
      </g>

      <g id="pms-node" transform="translate(70, 114)">
        <image class="icon" href="/services-static/img/pms.svg" x="2" y="-12" />
        <circle id="pms" class="node" r="1.5" filter="url(#glow)" />
        <text id="nodes_pms" class="circle-text" x="0" y="1"></text>
        <text x="5" y="2">pms</text>
      </g>

      <g id="beat-node" transform="translate(90, 74)">
        <image class="icon" href="/services-static/img/beat.svg" x="2" y="-12" />
        <circle id="beat" class="node" r="1.5" filter="url(#glow)" />
        <text id="nodes_beat" class="circle-text" x="0" y="1"></text>
        <text x="5" y="2">beat</text>
      </g>

      <g id="core-node" transform="translate(90, 94)">
        <image class="icon" href="/services-static/img/core.svg" x="2" y="-12" />
        <circle id="core" class="node" r="1.5" filter="url(#glow)" />
        <text id="nodes_core" class="circle-text" x="0" y="1"></text>
        <a id="core_link_parent" target="_blank">
          <circle id="core_link" class="link" cx="7" cy="-7" r="7"><title>Migasfree API</title></circle>
        </a>
        <text x="5" y="2">core</text>
      </g>

      <g id="worker-node" transform="translate(90, 114)">
        <image class="icon" href="/services-static/img/worker.svg" x="2" y="-12" />
        <circle id="worker" class="node" r="1.5" filter="url(#glow)" />
        <text id="nodes_worker" class="circle-text" x="0" y="1"></text>
        <a id="worker_link_parent" target="_blank">
          <circle id="worker_link" class="link" cx="7" cy="-7" r="7"><title>Worker Console</title></circle>
        </a>
        <text x="4" y="2">worker</text>
      </g>

      <g id="database-node" transform="translate(110, 74)">
        <image class="icon" href="/services-static/img/database.svg" x="2" y="-12" />
        <circle id="database" class="node" r="1.5" filter="url(#glow)" />
        <a id="database_link_parent" target="_blank">
          <circle id="database_link" class="link" cx="7" cy="-7" r="7"><title>Database Console</title></circle>
        </a>
        <text x="3" y="2">database</text>
      </g>

      <g id="datastore-node" transform="translate(110, 94)">
        <image class="icon" href="/services-static/img/datastore.svg" x="2" y="-12" />
        <circle id="datastore" class="node" r="1.5" filter="url(#glow)" />
        <a id="datastore_link_parent" target="_blank">
          <circle id="datastore_link" class="link" cx="7" cy="-7" r="7"><title>Datastore Console</title></circle>
        </a>
        <text x="3" y="2">datastore</text>
      </g>

      <g id="datashare-node" transform="translate(110, 114)">
        <image class="icon" href="/services-static/img/datashare.svg" x="2" y="-12" />
        <circle id="datashare_console" class="node" r="1.5" filter="url(#glow)" />
        <a id="datashare_console_link_parent" target="_blank">
          <circle id="datashare_console_link" class="link" cx="7" cy="-7" r="7"><title>Datashare Console</title></circle>
        </a>
        <text x="3" y="2">datashare</text>
      </g>

      <g id="certbot-node" transform="translate(130, 74)">
        <image class="icon" href="/services-static/img/certbot.svg" x="2" y="-12" />
        <circle id="certbot" class="node" r="1.5" />
        <text x="4" y="2">certbot</text>
      </g>

      <g id="assistant-node" transform="translate(130, 94)">
        <image class="icon" href="/services-static/img/assistant.svg" x="2" y="-12" />
        <circle id="assistant" class="node" r="1.5" filter="url(#glow)" />
        <a id="assistant_link_parent" target="_blank">
          <circle id="assistant_link" class="link" cx="7" cy="-7" r="7"><title>Assistant</title></circle>
        </a>
        <text x="3" y="2">assistant</text>
      </g>

      <g id="mcp-server-node" transform="translate(130, 114)">
        <image class="icon" href="/services-static/img/mcp-server.svg" x="2" y="-12" />
        <circle id="mcp-server" class="node" r="1.5" filter="url(#glow)" />
        <text x="3" y="2">mcp server</text>
      </g>
    </svg>
  </div>

  <!-- Logs Section (Collapsible) -->
  <div class="logs-section">
    <div class="logs-header" id="logs-toggle">
      <h2>Messages Log</h2>
      <span class="toggle-icon" id="toggle-icon">▼</span>
    </div>
    <div class="logs-content" id="logs-content">
      <div class="logs-table-container" id="logs-container">
        <p class="loading">Loading messages...</p>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // Configuration
      const CONFIG = {
        infoEndpoint: '/services/info',
        streamEndpoint: '/services/stream',
        reconnectDelay: 5000,
        waitingThreshold: 5000,
        welcomeMessages: ['salut!', 'Hi!', '¡hola!', '¡hola, co!', 'kaixo!', 'ola!', 'Hallo!'],
        logsColumns: ['timestamp', 'service', 'text', 'node', 'container'],
        serviceList: [
          'portainer', 'proxy', 'ca',
          'console', 'public', 'pms',
          'beat', 'core', 'worker',
          'database', 'datastore', 'datashare_console',
          'certbot', 'assistant', 'mcp-server'
        ],
        consoleServices: [
          'portainer', 'proxy', 'ca',
          'console',
          'core', 'worker',
          'database', 'datastore', 'datashare_console',
          'assistant'
        ],
        infoData: null,
      };

      const state = {
        eventSource: null,
        lastUpdate: Date.now(),
        serviceStates: {},
        pmsServices: {},
        waiting: true,
        wasDisconnected: false,
        allHealthy: false,
        logsExpanded: false,
        logsData: []
      };

      // DOM Cache
      const dom = {
        nodes: {},
        links: {},
        nodeTexts: {},
        mascot: null,
        message: null,
        messageServ: null,
        organization: null,
        stack: null,
        tag: null,
        logsToggle: null,
        logsContent: null,
        logsContainer: null,
        toggleIcon: null
      };

      // Initialize DOM cache
      function cacheDOMElements() {
        dom.mascot = document.getElementById('mascot');
        dom.message = document.getElementById('message');
        dom.messageServ = document.getElementById('message_serv');
        dom.organization = document.getElementById('organization');
        dom.stack = document.getElementById('stack');
        dom.tag = document.getElementById('tag');
        dom.logsToggle = document.getElementById('logs-toggle');
        dom.logsContent = document.getElementById('logs-content');
        dom.logsContainer = document.getElementById('logs-container');
        dom.toggleIcon = document.getElementById('toggle-icon');

        // Cache all service nodes
        CONFIG.serviceList.forEach(elementId => {
          dom.nodes[elementId] = document.getElementById(elementId);
          dom.nodeTexts[elementId] = document.getElementById(`nodes_${elementId}`);
        });

        // Cache console links
        CONFIG.consoleServices.forEach(service => {
          const linkParent = document.getElementById(`${service}_link_parent`);
          const link = document.getElementById(`${service}_link`);
          if (linkParent) dom.links[service] = linkParent;
          else if (link) dom.links[service] = link;
        });

        // Special case for public link
        const publicLink = document.getElementById('public_link');
        if (publicLink) dom.links.public = publicLink;
      }

      async function fetchInfo() {
        try {
          const response = await fetch(CONFIG.infoEndpoint);
          if (!response.ok) throw new Error('Error getting /services/info');
          const info = await response.json();
          CONFIG.infoData = info;
          dom.organization.textContent = info.organization || '';
          dom.stack.textContent = `stack: ${info.stack || ''}`;
          dom.tag.textContent = `migasfree server: ${info.tag || ''}`;
          return info;
        } catch (error) {
          console.error('Failed to load info:', error);
          return null;
        }
      }

      function setupLinks() {
        const host = window.location.host;
        const links = {
          portainer_link_parent: `https://portainer-${host}`,
          proxy_link_parent: `https://${host}/stats`,
          ca_link_parent: `https://${host}/ca/docs`,
          console_link_parent: `https://${host}/`,
          core_link_parent: `https://${host}/docs/`,
          worker_link_parent: `https://worker-${host}/tasks`,
          database_link_parent: `https://database-${host}`,
          datastore_link_parent: `https://datastore-${host}`,
          datashare_console_link_parent: `https://datashare-${host}`,
          assistant_link_parent: `https://assistant-${host}`
        };

        Object.entries(links).forEach(([id, href]) => {
          const el = document.getElementById(id);
          if (el) el.setAttribute('href', href);
        });

        // Public link special handling
        const publicLink = document.getElementById('public_link');
        if (publicLink) {
          publicLink.style.cursor = 'pointer';
          publicLink.addEventListener('click', () => {
            window.open(`https://${host}/pool/`, '_blank');
            window.open(`https://${host}/public/`, '_blank');
          });
        }
      }

      function getServiceName(fullName) {
        if (!CONFIG.infoData) return fullName;
        const stack = CONFIG.infoData.stack;

        if (fullName.startsWith('infra_')) {
          return fullName.replace('infra_', '');
        }

        if (fullName.startsWith(`${stack}_`)) {
          return fullName.replace(`${stack}_`, '');
        }

        return fullName;
      }

      function getColorFromStatus(status) {
        const colorMap = {
          'healthy': '#a9dfbf',   // green
          'degraded': '#f39c12',  // orange
          'starting': '#f9e79f',  // yellow
          'down': '#e74c3c',      // red
          'unknown': '#95a5a6'    // gray
        };
        return colorMap[status] || 'lightgray';
      }

      function updateServiceNode(serviceName, statusInfo) {
        const node = dom.nodes[serviceName];
        if (!node) {
          console.warn(`Node not found for service: ${serviceName}`);
          return;
        }

        console.debug(`${serviceName} statusInfo:`, statusInfo);

        const isDisabled = CONFIG.infoData?.disabled?.includes(serviceName);

        let color;
        if (isDisabled) {
          color = 'lightgray';
        } else {
          color = getColorFromStatus(statusInfo.status);
        }
        console.debug(`${serviceName} color: ${color}`)

        node.style.fill = color;
        node.style.display = 'block';

        // Updates nodes if > 1
        if (dom.nodeTexts[serviceName]) {
          console.debug('nodeText:', dom.nodeTexts[serviceName]);
          const nodeCount = statusInfo.running || 0;
          dom.nodeTexts[serviceName].textContent = nodeCount > 1 ? nodeCount : '';
        }

        // Updates console link visibility
        const link = dom.links[serviceName];
        if (link) {
          const shouldShow = statusInfo.running > 0 && !isDisabled;
          console.debug(`${serviceName} shouldShow: ${shouldShow}`)
          link.style.display = shouldShow ? 'block' : 'none';
          console.debug('dom.link:', link);
        }

        state.serviceStates[serviceName] = statusInfo;
      }

      function updatePMSNode() {
        const node = dom.nodes.pms;
        console.debug('updatePMSNode node:', node);
        if (!node) return;

        const pmsServiceNames = Object.keys(state.pmsServices);
        console.debug('pmsServiceNames', pmsServiceNames, pmsServiceNames.length);
        if (pmsServiceNames.length === 0) {
          node.style.display = 'none';
          return;
        }

        let totalRunning = 0;
        let totalDesired = 0;
        let anyDown = false;
        let anyDegraded = false;

        pmsServiceNames.forEach(name => {
          const status = state.pmsServices[name];
          totalRunning += status.running || 0;
          totalDesired += status.desired || 0;
          if (status.status === 'down') anyDown = true;
          if (status.status === 'degraded' || status.status === 'starting') anyDegraded = true;
        });

        let color = '#a9dfbf';  // green
        if (anyDown) color = '#e74c3c';
        else if (anyDegraded) color = '#f39c12';
        else if (totalRunning < totalDesired) color = '#f39c12';
        console.debug(`updatePMSNode color: ${color}`)

        node.style.fill = color;
        node.style.display = 'block';

        if (dom.nodeTexts.pms) {
          dom.nodeTexts.pms.textContent = totalRunning > 0 ? totalRunning : '';
        }
      }

      function updateMascot() {
        const now = Date.now();
        let sprite, prefix;

        const allHealthy = Object.values(state.serviceStates).every(s => s.status === 'healthy');
        const anyDown = Object.values(state.serviceStates).some(s => s.status === 'down');
        const anyDegraded = Object.values(state.serviceStates).some(s =>
          s.status === 'degraded' || s.status === 'starting'
        );

        if (allHealthy && Object.keys(state.serviceStates).length > 0) {
          sprite = Math.floor((now / 1000) % 2);
          prefix = 'mascot-ok';
          dom.message.textContent = 'ready';
          dom.messageServ.textContent = '';
          state.allHealthy = true;
        } else if (anyDown) {
          sprite = Math.floor((now / 1000) % 2);
          prefix = 'mascot-starting';

          const downService = Object.entries(state.serviceStates).find(([_, s]) => s.status === 'down');
          if (downService) {
            dom.messageServ.textContent = downService[0];
            dom.message.textContent = `${downService[1].running}/${downService[1].desired ?? 1} down`;
          }
          state.allHealthy = false;
        } else if (anyDegraded) {
          sprite = Math.floor((now / 1000) % 3);
          prefix = 'mascot-checking';

          const degradedService = Object.entries(state.serviceStates).find(([_, s]) =>
            s.status === 'degraded' || s.status === 'starting'
          );
          if (degradedService) {
            dom.messageServ.textContent = degradedService[0];
            dom.message.textContent = `${degradedService[1].running}/${degradedService[1].desired ?? 1} ${degradedService[1].status}`;
          }
          state.allHealthy = false;
        } else {
          sprite = 0;
          prefix = 'mascot-ok';
          state.allHealthy = false;
        }

        dom.mascot.setAttribute('href', `/services-static/img/${prefix}-${sprite}.svg`);
      }

      function toggleLogs() {
        state.logsExpanded = !state.logsExpanded;

        if (state.logsExpanded) {
          dom.logsContent.classList.add('expanded');
          dom.toggleIcon.classList.add('expanded');
          if (state.logsData.length > 0) {
            dom.logsContainer.innerHTML = buildLogsTable(state.logsData);
          } else {
            dom.logsContainer.innerHTML = '<p class="empty">No messages available.</p>';
          }
        } else {
          dom.logsContent.classList.remove('expanded');
          dom.toggleIcon.classList.remove('expanded');
        }

        const h2 = dom.logsToggle.querySelector('h2');
        if (h2) {
          h2.textContent = `Messages Log (${state.logsData.length})`;
        }
      }

      function handleStatusSSEMessage(event) {
        try {
          state.waiting = false;
          state.lastUpdate = Date.now();

          console.debug('event.data', event.data);
          const data = JSON.parse(event.data);
          console.debug('Status SSE event received:', data);

          if (!data.service || !data.status) {
            console.warn('Invalid Status SSE data:', data);
            return;
          }

          const fullServiceName = data.service;
          const serviceName = getServiceName(fullServiceName);
          console.debug('handleStatusSSEMessage', serviceName, data.status);

          if (serviceName.startsWith('pms-')) {
            state.pmsServices[serviceName] = data.status;
            updatePMSNode();
          } else {
            updateServiceNode(serviceName, data.status);
          }

          updateMascot();
          state.wasDisconnected = false;
        } catch (error) {
          console.error('Status SSE parse error:', error);
        }
      }

      function handleLogsSSEMessage(event) {
        try {
          console.debug('event.data', event.data);
          const data = JSON.parse(event.data);
          console.debug('Logs SSE event received:', data);

          if (!data.service || !data.container) {
            console.warn('Invalid Logs SSE data:', data);
            return;
          }

          // Add new message to beginning of array
          state.logsData.unshift(data);

          // Keep only last 500 messages
          if (state.logsData.length > 500) {
            state.logsData = state.logsData.slice(0, 500);
          }

          // Update table if expanded
          if (state.logsExpanded && dom.logsContainer) {
            dom.logsContainer.innerHTML = buildLogsTable(state.logsData);
          }

          if (dom.logsToggle) {
            const h2 = dom.logsToggle.querySelector('h2');
            if (h2) {
              h2.textContent = `Messages Log (${state.logsData.length})`;
            }
          }

          dom.message.textContent = data?.text || 'ready';
          dom.messageServ.textContent = data?.service || '';
        } catch (error) {
          console.error('Logs SSE parse error:', error);
        }
      }

      function buildLogsTable(data) {
        if (!data || data.length === 0) {
          return '<p class="empty">No messages available.</p>';
        }

        const thead = CONFIG.logsColumns.map(col => `<th>${escapeHtml(col)}</th>`).join('');

        const tbody = data.map(row => {
          const cells = CONFIG.logsColumns.map(col => {
            let value = row[col];

            if (value === undefined || value === null || value === '') {
              value = col === 'text' ? '🚀' : '';
            }

            return `<td>${escapeHtml(String(value))}</td>`;
          }).join('');

          return `<tr>${cells}</tr>`;
        }).join('');

        return `
          <table>
            <thead><tr>${thead}</tr></thead>
            <tbody>${tbody}</tbody>
          </table>
        `;
      }

      function initSSE() {
        if (state.eventSource) {
          state.eventSource.close();
        }

        state.waiting = true;
        state.eventSource = new EventSource(CONFIG.streamEndpoint);

        state.eventSource.addEventListener('status', handleStatusSSEMessage);
        state.eventSource.addEventListener('log', handleLogsSSEMessage);

        state.eventSource.addEventListener('ping', () => {
          console.debug('SSE ping received');
          state.lastUpdate = Date.now();
        });

        state.eventSource.onerror = () => {
          console.warn('SSE connection lost, reconnecting...');
          state.eventSource.close();
          showDisconnected();
          state.wasDisconnected = true;
          setTimeout(initSSE, CONFIG.reconnectDelay);
        };

        state.eventSource.onopen = () => {
          console.debug('SSE connected');
          state.wasDisconnected = false;
        };
      }

      // Logs SSE handling
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      function showWaiting() {
        dom.message.textContent = 'waiting...';
        dom.messageServ.textContent = '';
        dom.mascot.setAttribute('href', '/services-static/img/mascot-welcome.svg');
      }

      function showDisconnected() {
        dom.message.textContent = 'disconnected';
        dom.messageServ.textContent = '';
        dom.mascot.setAttribute('href', '/services-static/img/mascot-disconnect.svg');

        Object.values(dom.nodes).forEach(node => {
          if (node) node.style.display = 'none';
        });

        Object.values(dom.links).forEach(link => {
          if (link) link.style.display = 'none';
        });
      }

      function checkConnection() {
        if (!state.eventSource || state.eventSource.readyState !== 1) {
          showDisconnected();
          return;
        }

        const elapsed = Date.now() - state.lastUpdate;
        if (elapsed > CONFIG.waitingThreshold) {
          if (!state.waiting) {
            state.waiting = true;
            showWaiting();
          }
        }
      }

      function showWelcome() {
        const randomMsg = CONFIG.welcomeMessages[Math.floor(Math.random() * CONFIG.welcomeMessages.length)];
        dom.message.textContent = randomMsg;
        dom.messageServ.textContent = '';
        dom.mascot.style.display = 'none';
        dom.mascot.setAttribute('href', '/services-static/img/mascot-welcome.svg');

        setTimeout(() => {
          dom.mascot.style.display = 'block';
        }, 100);

        Object.values(dom.nodes).forEach(node => {
          if (node) {
            node.style.fill = 'lightgray';
            node.style.display = 'none';
          }
        });

        Object.values(dom.links).forEach(link => {
          if (link) link.style.display = 'none';
        });
      }

      // Initialize
      async function init() {
        cacheDOMElements();
        setupLinks();
        showWelcome();

        CONFIG.infoData = await fetchInfo();

        if (CONFIG.infoData) {
          initSSE();
        }

        // Setup logs toggle
        if (dom.logsToggle) {
          dom.logsToggle.addEventListener('click', toggleLogs);
        }

        setInterval(checkConnection, 2000);
        setInterval(updateMascot, 1000);
      }

      // Cleanup on unload
      window.addEventListener('beforeunload', () => {
        if (state.eventSource) {
          state.eventSource.close();
        }
      });

      // Start when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
